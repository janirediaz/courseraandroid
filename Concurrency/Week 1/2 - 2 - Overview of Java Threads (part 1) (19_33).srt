1
00:00:00,720 --> 00:00:03,510
The first topic we're going to
talk about here is Java threads.

2
00:00:03,510 --> 00:00:07,394
And they're, of course, important as the
foundation for concurrency in Android, and

3
00:00:07,394 --> 00:00:10,448
you'll also need to know something
about threads in order to do some of

4
00:00:10,448 --> 00:00:11,868
the assignments in the course.

5
00:00:11,868 --> 00:00:16,789
Although later in the course, we'll
be covering other Android concurrency

6
00:00:16,789 --> 00:00:20,890
frameworks that alleviate the need
to know a lot about threads.

7
00:00:22,920 --> 00:00:25,740
So the first thing we're going to be doing
here is we're going to be talking about

8
00:00:26,930 --> 00:00:29,805
what the Java threading mechanisms are,
and

9
00:00:29,805 --> 00:00:34,440
how they work to program
concurrent software.

10
00:00:35,720 --> 00:00:40,259
To understand Java Threads, it helps to
understand how to program Java Threads,

11
00:00:40,259 --> 00:00:43,903
and in order to do that you have to
give the thread some code to run.

12
00:00:43,903 --> 00:00:48,245
And there's a couple of different ways
to give Java Threads some code to run.

13
00:00:48,245 --> 00:00:50,889
One thing that you need
to do is you need to,

14
00:00:50,889 --> 00:00:54,080
one way to do it is to
extend the thread class.

15
00:00:54,080 --> 00:00:58,370
Thread is a class that's built
into the Java language, and so

16
00:00:58,370 --> 00:00:59,850
it's always available.

17
00:00:59,850 --> 00:01:03,150
And so
one thing you can do is come along and

18
00:01:03,150 --> 00:01:06,890
subclass from thread, and
override the run method.

19
00:01:08,150 --> 00:01:09,190
So here's a simple example.

20
00:01:09,190 --> 00:01:13,749
We're going to create and start a thread
using a named subclass of a thread.

21
00:01:13,749 --> 00:01:18,539
So we have a class called MyThread that
extends thread, and the method that does

22
00:01:18,539 --> 00:01:22,629
the work is going to be in the run,
the Run Hook Method as it's called.

23
00:01:22,629 --> 00:01:26,920
The hook method is just the method that
can be overridden by a subclass to provide

24
00:01:26,920 --> 00:01:30,890
some functionality that the base class
doesn't know about how to do, but

25
00:01:30,890 --> 00:01:31,867
it knows to call.

26
00:01:31,867 --> 00:01:35,142
Here we go ahead and
make a new instance of MyThread, and

27
00:01:35,142 --> 00:01:36,824
then we can start MyThread.

28
00:01:36,824 --> 00:01:40,500
And as we'll see later,
that basically launches a new thread of

29
00:01:40,500 --> 00:01:44,586
control on the virtual machine and
the underlying operating system and

30
00:01:44,586 --> 00:01:49,460
then that begins to run the run hook
method that was defined earlier.

31
00:01:49,460 --> 00:01:53,270
You could also do this as a one liner
using an anonymous thread instance.

32
00:01:53,270 --> 00:01:57,270
So down here you could say new
MyThread.start, and that will go ahead and

33
00:01:57,270 --> 00:01:58,200
start the thread to run.

34
00:01:59,700 --> 00:02:02,030
A second way to run a thread,
create a thread and

35
00:02:02,030 --> 00:02:04,300
make a thread run,
is to implement the runnable interface.

36
00:02:04,300 --> 00:02:09,550
So, in this particular case
you're going to basically

37
00:02:09,550 --> 00:02:14,400
implement a runnable and
override the run hook method.

38
00:02:14,400 --> 00:02:16,680
And there's a couple of ways to do this.

39
00:02:16,680 --> 00:02:18,180
One way to do this is to create and

40
00:02:18,180 --> 00:02:21,420
start a thread using a named
class as the runnable.

41
00:02:21,420 --> 00:02:24,800
So, here we have MyRunnable,
the implements Runnable, and

42
00:02:24,800 --> 00:02:25,990
it fills in the run method.

43
00:02:25,990 --> 00:02:30,540
And then down here we can say
new myRunnable and we can

44
00:02:30,540 --> 00:02:35,500
then pass that runnable to a new instance
of the thread and tell that to start.

45
00:02:35,500 --> 00:02:39,300
So this is an anonymous thread,
but it's a named instance

46
00:02:39,300 --> 00:02:42,650
of runnable that we're instantiating
here and we're starting it.

47
00:02:42,650 --> 00:02:45,555
So you can see that there's an extra step
here because we're making a runnable and

48
00:02:45,555 --> 00:02:47,401
then we're giving that
runnable to the thread.

49
00:02:49,665 --> 00:02:54,400
Another way to do things is to
use an anonymous inner class.

50
00:02:54,400 --> 00:02:57,980
So rather than going ahead and making it
an object as we've done here and then

51
00:02:57,980 --> 00:03:03,910
explicitly passing that to thread, instead
we can go ahead and say new thread.

52
00:03:03,910 --> 00:03:09,350
And then inside the constructor
parameter to thread,

53
00:03:09,350 --> 00:03:15,180
we make ourselves an anonymous instance
of an inner class called Anonymous or

54
00:03:15,180 --> 00:03:17,790
it doesn't have a name really,
it's just an instance of a runnable.

55
00:03:17,790 --> 00:03:20,240
And then we can go ahead and
override the run method and

56
00:03:20,240 --> 00:03:21,950
put the code to run in here.

57
00:03:21,950 --> 00:03:26,990
So this is a much more, a bit more
concise way, I guess by some definition

58
00:03:26,990 --> 00:03:29,140
of concise because you don't
have to define a separate class.

59
00:03:30,660 --> 00:03:36,300
So it turns out that this approach is
used very heavily in Java code and

60
00:03:36,300 --> 00:03:40,050
in Android code, you'll see this used
all over the place this callbacks and

61
00:03:40,050 --> 00:03:45,010
various kinds of things to
handle logic as callbacks.

62
00:03:45,010 --> 00:03:49,130
If you're in a position to use Java 8,
there's a really cool extension to this.

63
00:03:49,130 --> 00:03:50,450
Or, actually,
it's not really an extension,

64
00:03:50,450 --> 00:03:54,570
it's actually a simplification using
something called Lambda Expressions.

65
00:03:54,570 --> 00:03:56,560
And so all this complicated,

66
00:03:56,560 --> 00:04:01,070
boiler plate code here disappears and
it just looks like this.

67
00:04:01,070 --> 00:04:05,360
So you basically say open
close paren indicating

68
00:04:05,360 --> 00:04:08,060
a method that takes no parameters.

69
00:04:08,060 --> 00:04:09,460
And then you have an arrow and

70
00:04:09,460 --> 00:04:13,760
then you write the code that you
want to run in the run method here.

71
00:04:13,760 --> 00:04:18,363
Now unfortunately Android doesn't
really support Java 8 yet,

72
00:04:18,363 --> 00:04:20,293
unless you use Retroland.

73
00:04:20,293 --> 00:04:22,525
I think its called Retro Lambda and so

74
00:04:22,525 --> 00:04:25,191
we're not going to do
a lot of Java 8 stuff.

75
00:04:25,191 --> 00:04:28,689
I just wanted to point out that there is
some cool stuff coming down the pipe that

76
00:04:28,689 --> 00:04:31,392
you can use now if you have
the ability to program Java 8, and

77
00:04:31,392 --> 00:04:33,100
it makes your code a lot more concise.

78
00:04:35,170 --> 00:04:38,170
So that's basically how we go ahead and

79
00:04:38,170 --> 00:04:40,300
create threads by
a couple different means.

80
00:04:41,320 --> 00:04:44,610
Let's not talk about how to pass
parameters to a started thread.

81
00:04:45,610 --> 00:04:50,030
So the run method that's defined
in Java Thread and in Runnable

82
00:04:50,030 --> 00:04:54,970
doesn't take any parameters, as you
can see, it's a no parameter method.

83
00:04:54,970 --> 00:04:57,390
So how can we pass parameters to threads?

84
00:04:57,390 --> 00:04:59,499
Well there are a couple of
different ways to do it.

85
00:04:59,499 --> 00:05:06,189
So one way to do this is to basically
create a class constructor and

86
00:05:06,189 --> 00:05:10,813
then go ahead and
have that constructor store

87
00:05:10,813 --> 00:05:14,950
the information in private fields, and

88
00:05:14,950 --> 00:05:20,443
then access those fields
within the run hook method.

89
00:05:20,443 --> 00:05:25,246
So here's a case where we extend Runnable
or sorry we implement Runnable, and

90
00:05:25,246 --> 00:05:27,550
then we add a private field.

91
00:05:27,550 --> 00:05:30,770
We store that field in
the constructor of this class, and

92
00:05:30,770 --> 00:05:35,030
then the run method goes ahead and
accesses that via the field.

93
00:05:35,030 --> 00:05:37,200
So that's one way to do it.

94
00:05:37,200 --> 00:05:39,300
Another way to do it is
to add a Setter Method.

95
00:05:39,300 --> 00:05:41,180
So rather than just using a constructor,

96
00:05:41,180 --> 00:05:43,250
you can also have a method
called setThreadType, or

97
00:05:43,250 --> 00:05:46,610
whatever you want to call it, and
then you do the same kind of thing.

98
00:05:46,610 --> 00:05:48,610
You assign the value and

99
00:05:48,610 --> 00:05:52,500
then you go ahead and
use the value inside of the run method.

100
00:05:52,500 --> 00:05:56,349
So those are the typical ways of getting
access to parameters that you want to pass

101
00:05:56,349 --> 00:05:59,636
to a thread, since you can't pass
them to the run method directly.

102
00:06:02,294 --> 00:06:05,630
Let's talk about Running Java Threads.

103
00:06:05,630 --> 00:06:11,050
So, after start is called,
the underlying virtual machine and

104
00:06:11,050 --> 00:06:14,030
operating system would go ahead and
create the threads resources.

105
00:06:14,030 --> 00:06:17,670
And the Java virtual machine will then
call the run hook method to start

106
00:06:17,670 --> 00:06:18,920
doing the work.

107
00:06:18,920 --> 00:06:22,630
And this involves a number
of layers in the Java stack.

108
00:06:22,630 --> 00:06:27,460
So we've got the operating system kernel
of course, and the system libraries.

109
00:06:27,460 --> 00:06:32,160
These are typical written in C or C++,
usually C for the case of threads.

110
00:06:32,160 --> 00:06:37,073
Then there's a Java virtual machine which
is typically written in some Java with

111
00:06:37,073 --> 00:06:38,381
a lot of Native code.

112
00:06:38,381 --> 00:06:43,110
And then that exposes an interface
that's used by the Thread Libraries in

113
00:06:43,110 --> 00:06:44,871
Java you took concurrent.

114
00:06:44,871 --> 00:06:47,710
And so those are the layers
we're talking about here.

115
00:06:47,710 --> 00:06:51,820
So, when someone says new thread
that makes a new object, but

116
00:06:51,820 --> 00:06:54,540
only when they call start
are the real resources

117
00:06:54,540 --> 00:06:56,920
allocated by the Java virtual machine and
operating system.

118
00:06:56,920 --> 00:06:59,640
And we'll talk more about that
in the next set of slides.

119
00:06:59,640 --> 00:07:03,700
And once start method returns,
then run is up and running, and

120
00:07:03,700 --> 00:07:06,050
then things are running concurrently.

121
00:07:06,050 --> 00:07:10,127
And so the original thread that created
the new thread, and the new thread

122
00:07:10,127 --> 00:07:14,893
are able to run concurrently and they're
able to block independently of each other.

123
00:07:16,416 --> 00:07:20,660
Generally any thread, any code can be
run in a thread, although there are some

124
00:07:20,660 --> 00:07:25,120
limitations that are typically
framework or platform specific.

125
00:07:25,120 --> 00:07:29,111
So, you can do almost
everything in a run method.

126
00:07:29,111 --> 00:07:33,726
However, windowing toolkits often
restrict which thread can access the GUI

127
00:07:33,726 --> 00:07:38,128
components, the various things like
the views, and the dialogues, and

128
00:07:38,128 --> 00:07:39,490
the widgets and so on.

129
00:07:39,490 --> 00:07:42,400
Those can typically only be accessed
by the main thread of control.

130
00:07:42,400 --> 00:07:46,660
And you can find out more about that
here in the context of Android,

131
00:07:46,660 --> 00:07:49,390
where they talk about something called the
UI thread, or the user interface thread.

132
00:07:49,390 --> 00:07:51,300
And we'll talk a lot more about
that later in the course.

133
00:07:53,050 --> 00:07:57,861
As long as the run method hasn't returned,
either gracefully or

134
00:07:57,861 --> 00:08:02,764
non-gracefully, the thread will
continue to live and be alive.

135
00:08:02,764 --> 00:08:05,450
So, however, if it's logically alive but

136
00:08:05,450 --> 00:08:10,171
of course the underlying operating
system in virtual machines scheduler can

137
00:08:10,171 --> 00:08:13,814
suspend and resume a thread
many times over its lifecycle.

138
00:08:13,814 --> 00:08:16,971
Put it to sleep for
reasons of being able to do preemption and

139
00:08:16,971 --> 00:08:20,840
other kinds of thread scheduling
magic that the operating system does.

140
00:08:22,140 --> 00:08:24,970
If you want a thread to execute forever,

141
00:08:24,970 --> 00:08:28,150
then you simply need to put it in
a loop that runs indefinitely.

142
00:08:28,150 --> 00:08:32,630
So you would say, while true, or
you'd say four and just have a four with

143
00:08:32,630 --> 00:08:36,500
no condition expression that
ever causes it to terminate.

144
00:08:36,500 --> 00:08:39,590
Obviously, you need to be careful
about this in production systems,

145
00:08:39,590 --> 00:08:41,760
because, often times,
you need to shut threads down.

146
00:08:41,760 --> 00:08:42,900
And we'll talk more about that later.

147
00:08:44,570 --> 00:08:48,780
After run returns the thread is no
longer considered to be alive, so if you

148
00:08:48,780 --> 00:08:53,420
called the is alive method, it would
return false after it's been shut down.

149
00:08:53,420 --> 00:08:56,340
You can use another method called Join,
which is important and

150
00:08:56,340 --> 00:08:59,710
is used in various programming
assignments that we'll have here,

151
00:08:59,710 --> 00:09:03,460
that allows one thread to wait for
the completion of another.

152
00:09:03,460 --> 00:09:05,960
So, join allows one thread.

153
00:09:05,960 --> 00:09:07,770
It doesn't have to be the thread
that created the thread, by the way.

154
00:09:07,770 --> 00:09:09,080
It could be a different thread.

155
00:09:09,080 --> 00:09:11,210
It allows it to wait for
the thread to complete.

156
00:09:11,210 --> 00:09:13,250
And when the thread completes,
when the thread exits,

157
00:09:13,250 --> 00:09:15,130
then the other thread
can return from join.

158
00:09:15,130 --> 00:09:18,790
And we'll see later that there's
various methods for join.

159
00:09:18,790 --> 00:09:25,050
It's an overloaded method, so it has
time outs, or non time out versions.

160
00:09:26,470 --> 00:09:31,620
Join is what forms something called
a simple means of barrier synchronization.

161
00:09:31,620 --> 00:09:34,100
We'll talk a lot more about
barrier synchronization later.

162
00:09:34,100 --> 00:09:36,690
Barrier synchronization is used
to allow threads to wait for

163
00:09:36,690 --> 00:09:38,380
each other in various ways.

164
00:09:38,380 --> 00:09:41,820
And there are other mechanisms
besides join in Java.

165
00:09:41,820 --> 00:09:46,700
Things like Countdown Latches, and
Cyclic Barriers, and Phasers, and so on.

166
00:09:46,700 --> 00:09:49,700
And I'll give you some pointers
to more information to find about

167
00:09:49,700 --> 00:09:50,360
those things later.

168
00:09:51,830 --> 00:09:56,740
The thread can also simply evaporate,
where nobody waits to join with it.

169
00:09:56,740 --> 00:10:00,420
In which case, it just goes away, and
then the virtual machine and the operating

170
00:10:00,420 --> 00:10:03,480
system recycles the resources that
are associated with the thread.

171
00:10:06,240 --> 00:10:09,430
There's a number of common Java Thread
methods that are worth knowing about.

172
00:10:09,430 --> 00:10:13,480
There are lots of methods, but we are just
going to talk about some of them.

173
00:10:13,480 --> 00:10:15,370
These are the most common ones.

174
00:10:15,370 --> 00:10:18,570
There's one called setDaemon
that marks a thread as a daemon.

175
00:10:18,570 --> 00:10:23,570
A daemon thread is a thread that's
defined in such a way that it's lifetime

176
00:10:23,570 --> 00:10:28,640
is a function of the number of other
nonDaemon threads in the process.

177
00:10:28,640 --> 00:10:31,410
So when all the other nonDaemon
threads exit then any

178
00:10:31,410 --> 00:10:33,290
daemon threads will also exit.

179
00:10:33,290 --> 00:10:37,890
Conversely, with normal threads,
if the main thread exits,

180
00:10:37,890 --> 00:10:40,540
then the other threads
can continue to execute.

181
00:10:42,500 --> 00:10:46,630
There's a method called Start,
as we saw that initiates thread execution.

182
00:10:46,630 --> 00:10:50,200
There's an abstract method called Run
which is a hook method for user code.

183
00:10:50,200 --> 00:10:54,100
That's the method you fill in or
you provide a runnable that fills it in.

184
00:10:54,100 --> 00:10:58,470
There's a method called Join which is used
for various synchronization to wait for

185
00:10:58,470 --> 00:11:00,120
threads to finish.

186
00:11:00,120 --> 00:11:03,310
Sleep is used to wait for a certain
amount of time to elapse, there's

187
00:11:03,310 --> 00:11:07,830
a couple different variants of sleep that
wait for, milliseconds or nanoseconds.

188
00:11:08,900 --> 00:11:12,750
You can find out what the current thread
is by calling currentThread, which is

189
00:11:12,750 --> 00:11:17,690
the Static method that will return
the current thread, which can be used for

190
00:11:17,690 --> 00:11:21,610
debugging purposes and other mechanisms
and other algorithms we'll see later.

191
00:11:23,030 --> 00:11:25,850
There's a couple of interesting ways
of causing threads to shut down.

192
00:11:25,850 --> 00:11:27,600
We're going to have a whole
section about this in a minute.

193
00:11:27,600 --> 00:11:32,970
But in a nutshell, interrupt can be used
to post an interrupt request to a thread.

194
00:11:32,970 --> 00:11:36,810
And that's really the only graceful way

195
00:11:36,810 --> 00:11:38,670
of having threads tell
each other to shut down.

196
00:11:38,670 --> 00:11:39,990
You can't really stop them.

197
00:11:39,990 --> 00:11:42,580
And we'll talk about why
you can't stop them later.

198
00:11:42,580 --> 00:11:43,490
But you can interrupt them.

199
00:11:43,490 --> 00:11:45,910
And that posts a request to a thread.

200
00:11:45,910 --> 00:11:49,068
And then, a thread can test to see
whether or not it's been interrupted, and

201
00:11:49,068 --> 00:11:50,586
there's a couple of ways to do that.

202
00:11:50,586 --> 00:11:54,748
There's a method called isInterrupted,
which is a non static method that checks

203
00:11:54,748 --> 00:11:57,110
to see whether a thread
has been interrupted.

204
00:11:57,110 --> 00:11:59,697
And you can call this method
multiple times without

205
00:11:59,697 --> 00:12:01,742
affecting the status of the interrupt,

206
00:12:01,742 --> 00:12:05,730
and there's another method called
the Interrupted which is a static method.

207
00:12:06,790 --> 00:12:10,858
And this checks to see whether the current
thread has been interrupted or not.

208
00:12:10,858 --> 00:12:14,723
And this actually clears the interrupt
status the first time it's called.

209
00:12:14,723 --> 00:12:17,042
So we'll talk more about
these things later,

210
00:12:17,042 --> 00:12:20,795
they're very important to understand
the differences and how they work.

211
00:12:20,795 --> 00:12:23,591
There are also methods
called setPriority and

212
00:12:23,591 --> 00:12:27,970
getPriority which are used to set and
get the priorities of the threads.

213
00:12:27,970 --> 00:12:31,961
And that's often useful to give a bump or
either a bump up or

214
00:12:31,961 --> 00:12:36,530
a bump down if you want to emphasize
some computations over others.

215
00:12:38,540 --> 00:12:43,430
These methods establish various,
so-called, Happens-Before orderings.

216
00:12:43,430 --> 00:12:45,661
Take a look here, you can find
out more about Happens-Before.

217
00:12:45,661 --> 00:12:49,060
Happens-Before is a very important
concept in Java concurrency, and

218
00:12:49,060 --> 00:12:50,590
in concurrency in general.

219
00:12:50,590 --> 00:12:53,870
Is it deals with how information
is shared and becomes visible and

220
00:12:53,870 --> 00:12:57,840
is made consistent between multiple
threads, which is especially important in

221
00:12:57,840 --> 00:13:01,970
today's multicore platforms, which, pretty
much everything is multicore these days.

222
00:13:01,970 --> 00:13:05,250
For example, when you start a thread,

223
00:13:05,250 --> 00:13:09,490
starting a thread happens before
the run method of the thread is called.

224
00:13:11,110 --> 00:13:15,720
Likewise, when a thread terminates,
the termination of

225
00:13:15,720 --> 00:13:19,370
the thread happens before the join
occurs with the terminated thread.

226
00:13:19,370 --> 00:13:22,050
And there's also many other examples

227
00:13:22,050 --> 00:13:26,150
in Java.util.concurrent of methods that
establish Happen-Before orderings.

228
00:13:26,150 --> 00:13:30,576
So, for example placing an object into
a concurrent collection happens-before

229
00:13:30,576 --> 00:13:34,280
the access or removal of
the element from that collection.

230
00:13:34,280 --> 00:13:38,110
And these are a very important concepts
because if you don't use synchronization

231
00:13:38,110 --> 00:13:42,130
properly you'll have problems with
Happens-Before relationships and

232
00:13:42,130 --> 00:13:45,860
you'll have problems with your
code not being consistent and

233
00:13:45,860 --> 00:13:47,720
visible and ordered properly.

234
00:13:47,720 --> 00:13:51,790
Now, luckily Android takes care
of an awful lot of these problems

235
00:13:51,790 --> 00:13:53,720
in its concurrency frameworks
that we'll talk about later.

236
00:13:55,010 --> 00:13:58,980
So now let's go ahead and
take a look at an example of Starting and

237
00:13:58,980 --> 00:14:01,210
Joining with Java Threads.

238
00:14:01,210 --> 00:14:06,160
And this is an example that you can
actually download here, from this website.

239
00:14:06,160 --> 00:14:09,960
And this demonstrates the use
of various Thread methods

240
00:14:09,960 --> 00:14:12,540
to implement an embarrassingly
parallel application.

241
00:14:12,540 --> 00:14:17,300
So I'll first go ahead and
explain what it does and

242
00:14:17,300 --> 00:14:19,490
then I'll show you
a little bit of the code.

243
00:14:19,490 --> 00:14:24,910
So this particular example spawns a bunch
of threads, these are worker threads and

244
00:14:24,910 --> 00:14:30,190
each of these threads searches for
words in a List of Strings.

245
00:14:30,190 --> 00:14:33,620
We have a List of Strings, and we have
a bunch of Threads and they search for

246
00:14:33,620 --> 00:14:34,710
words in those Threads.

247
00:14:35,810 --> 00:14:39,330
So we're going to call Thread.start()
to spawn a worker Thread for

248
00:14:39,330 --> 00:14:41,626
each element in the List of Strings.

249
00:14:41,626 --> 00:14:45,410
Let's say that there's ten elements in
the List of Strings, we might have ten

250
00:14:45,410 --> 00:14:50,120
Threads, one Thread would search
each String for words in the String.

251
00:14:52,060 --> 00:14:55,450
And then the main thread, and
this is the key point of this example,

252
00:14:55,450 --> 00:15:00,410
is going to use Thread.join to wait for
the worker Threads to finish running.

253
00:15:00,410 --> 00:15:03,480
And that's an example of a simple
form of barrier synchronization.

254
00:15:04,840 --> 00:15:07,359
No other java synchronization
mechanisms are needed for

255
00:15:07,359 --> 00:15:08,776
something that is this simple,

256
00:15:08,776 --> 00:15:12,459
because this is a very straight forward
example that is embarrassingly parallel.

257
00:15:12,459 --> 00:15:15,152
What that means is that
there's really little or

258
00:15:15,152 --> 00:15:19,297
no dependencies between the various
computations that are taking place.

259
00:15:19,297 --> 00:15:23,633
Later we'll talk about other,
more interesting Java synchronization

260
00:15:23,633 --> 00:15:27,045
mechanisms, like synchronized
statements and wait and

261
00:15:27,045 --> 00:15:30,475
notify mechanisms on
Java built in monitor op.

262
00:15:30,475 --> 00:15:32,905
Here's the source code for
the thread join test.

263
00:15:32,905 --> 00:15:35,735
As you can see, this is all in one file.

264
00:15:35,735 --> 00:15:40,430
So let's just kind of walk through the
file, and I will show you how it works.

265
00:15:41,630 --> 00:15:47,574
So Thread join test, you can see it's
got a string, bigger, there we go, so

266
00:15:47,574 --> 00:15:53,527
we've got ourselves an array of strings,
and they have funny names in them.

267
00:15:53,527 --> 00:15:56,603
You'll see why they have these
funny names in a second.

268
00:15:56,603 --> 00:16:00,560
And then there's a list of words
we're going to search for,

269
00:16:00,560 --> 00:16:03,566
which are just the names for
musical notes.

270
00:16:03,566 --> 00:16:07,500
So, what we're going to do is we're
going to spawn a separate thread

271
00:16:07,500 --> 00:16:10,890
the search each of these strings for
the musical notes.

272
00:16:10,890 --> 00:16:14,981
Now, of course, in real life, we probably
wouldn't use an array of strings,

273
00:16:14,981 --> 00:16:19,314
we'd have an array of files, or something
like that, but I'm just trying to keep it

274
00:16:19,314 --> 00:16:22,761
simple to focus on the concurrency and
synchronization aspects.

275
00:16:22,761 --> 00:16:28,334
So we call the class that does this search
one shot thread join, it's going to have

276
00:16:28,334 --> 00:16:33,508
a list of strings as input, and it is
going to have an array of words defined.

277
00:16:33,508 --> 00:16:37,519
And it's also going to have a list of
threads which are the threads that were

278
00:16:37,519 --> 00:16:41,136
created to do the searching, and
then we're also of course going to

279
00:16:41,136 --> 00:16:45,420
use these threads to join with
the results when we're done.

280
00:16:45,420 --> 00:16:50,264
So we come down here and
we have SearchOneShotThreadJoin,

281
00:16:50,264 --> 00:16:54,800
as you can see, well we set
the parameters passed in to the fields.

282
00:16:54,800 --> 00:17:00,160
We make ourselves a linklist of worker
threads, and then we go through

283
00:17:00,160 --> 00:17:05,430
the input size, that's the input we were
given, the list of strings to search.

284
00:17:05,430 --> 00:17:10,030
And for each string in the input,
we go ahead and make a new

285
00:17:10,030 --> 00:17:13,880
task using a factory method called
makeTask that we'll look at in a second.

286
00:17:13,880 --> 00:17:18,550
And we take the task, which is a Runnable,
we make a new thread,

287
00:17:18,550 --> 00:17:23,350
we add that thread to the list of threads
we're going to join with later, and

288
00:17:23,350 --> 00:17:24,710
then we go ahead and start the thread.

289
00:17:24,710 --> 00:17:25,930
So the thread is now running.

290
00:17:25,930 --> 00:17:28,650
So we're going to basically
spawn off a thread for

291
00:17:28,650 --> 00:17:30,555
every element in the input list.

292
00:17:30,555 --> 00:17:35,492
Then down here in the main thread,
we simply iterate through the list of

293
00:17:35,492 --> 00:17:38,717
worker threads, and
we call join on each one.

294
00:17:38,717 --> 00:17:43,025
And join of course will wait
until the thread is finished and

295
00:17:43,025 --> 00:17:45,350
then join will return.

296
00:17:45,350 --> 00:17:49,780
So this loop only exits after all the
threads are done with their processing.

297
00:17:49,780 --> 00:17:51,730
So that's what's called
Barrier Synchronization.

298
00:17:51,730 --> 00:17:54,800
You're using this to wait in
what's called an Exit Barrier.

299
00:17:56,000 --> 00:17:59,930
Here's the factor method that makes
the runable, when we call make task,

300
00:17:59,930 --> 00:18:03,510
we give at the index that we
are going to have in the list.

301
00:18:03,510 --> 00:18:06,560
We make a new runnable,
whose run method we'll go ahead and

302
00:18:06,560 --> 00:18:10,500
look up in the input list,
get the item at that location.

303
00:18:10,500 --> 00:18:14,620
And then it goes ahead and
it calls a method called Process Input.

304
00:18:14,620 --> 00:18:17,990
Keep in mind that this method will be
running in its own thread of control.

305
00:18:19,040 --> 00:18:25,800
And process input simply iterates through
the words that we're looking for.

306
00:18:25,800 --> 00:18:30,150
And it searches in the input
data one word at a time.

307
00:18:30,150 --> 00:18:33,730
And it keeps looking until
it finds all the words.

308
00:18:33,730 --> 00:18:38,120
And every time it finds a match, then it
goes ahead and it processes the result.

309
00:18:38,120 --> 00:18:38,960
And as you'll see in a second,

310
00:18:38,960 --> 00:18:41,670
that just goes ahead and
prints the result to the output.

311
00:18:42,720 --> 00:18:48,236
So it'll indicate whether it found a
particular word in a particular string for

312
00:18:48,236 --> 00:18:50,540
a particular thread.

313
00:18:52,020 --> 00:18:53,820
Then here is just the way
we print things out.

314
00:18:55,320 --> 00:18:59,005
Here's the main program, we go ahead and
start the thread join test.

315
00:18:59,005 --> 00:19:04,190
We go ahead and
we'll create a new instance and knowledge

316
00:19:04,190 --> 00:19:09,430
instance of search one shot thread join,
which will pass in the parameters and

317
00:19:09,430 --> 00:19:12,940
then that'll go ahead and run and
that will wait until it's finished.

318
00:19:12,940 --> 00:19:16,600
And we'll print all the results
out that happen to match.

319
00:19:18,640 --> 00:19:20,210
That's basically that simple program.

320
00:19:22,150 --> 00:19:26,420
You're welcome to take a look at this and
other programs as you see fit.

321
00:19:26,420 --> 00:19:31,980
And you can also go and take a look at the
website for more information about that.

