1
00:00:00,660 --> 00:00:03,013
The next topic here is
built-in monitor objects, and

2
00:00:03,013 --> 00:00:04,761
there are two parts to this discussion.

3
00:00:04,761 --> 00:00:07,799
We're going to talk about
what monitor objects are, and

4
00:00:07,799 --> 00:00:10,572
how they can be used to
ensure mutual exclusion and

5
00:00:10,572 --> 00:00:14,220
coordination between threads
running in a concurrent program.

6
00:00:15,730 --> 00:00:19,861
In order to do this, we're going to
show an example of a buggy concurrent

7
00:00:19,861 --> 00:00:23,502
Java program that's going to be
concurrently calling put and

8
00:00:23,502 --> 00:00:26,601
take methods on something
called the SimpleQueue.

9
00:00:26,601 --> 00:00:28,636
And we'll see there that
if we're not careful,

10
00:00:28,636 --> 00:00:30,580
we'll end up corrupting
the internal state.

11
00:00:32,840 --> 00:00:37,819
And we're going to show how to fix this
problem by applying monitor objects.

12
00:00:37,819 --> 00:00:38,556
And as we'll see,

13
00:00:38,556 --> 00:00:41,745
monitor objects will give us a bunch of
different features to make things better.

14
00:00:41,745 --> 00:00:46,024
They give us something called synchronized
methods and statements which use

15
00:00:46,024 --> 00:00:51,150
an entrance queue to ensure only one thing
at a time is running inside the object.

16
00:00:51,150 --> 00:00:54,330
And I'll also use a wait
wueue to be able to wait and

17
00:00:54,330 --> 00:00:57,630
notify to coordinate the interactions
between different threats.

18
00:00:59,630 --> 00:01:04,025
All these features I just described
are something called a monitor.

19
00:01:04,025 --> 00:01:05,639
A monitor is a pattern.

20
00:01:05,639 --> 00:01:11,061
It's a concurrency control construct
that's been around for 40 or 50 years.

21
00:01:11,061 --> 00:01:11,920
It's been around a very long time.

22
00:01:11,920 --> 00:01:16,575
And it's used for
synchronization in concurrent programs.

23
00:01:16,575 --> 00:01:20,145
There are three capabilities a monitor
provides to concurrent programs.

24
00:01:21,330 --> 00:01:26,410
The first thing it provides is it allows
you to ensure only one thread at a time

25
00:01:26,410 --> 00:01:30,170
is able to access critical
sections within an object.

26
00:01:31,180 --> 00:01:32,172
So that's one of the key features.

27
00:01:32,172 --> 00:01:35,948
Mutual exclusion is the fancy way
of saying one thing at a time, and

28
00:01:35,948 --> 00:01:39,230
we'll see some examples of that later.

29
00:01:39,230 --> 00:01:40,710
You can read more about
critical section here.

30
00:01:42,780 --> 00:01:47,140
It also ensures that threads
running in a monitor

31
00:01:47,140 --> 00:01:52,190
can block efficiently waiting for
certain conditions to become true.

32
00:01:52,190 --> 00:01:55,810
So, if you're unable to make forward
progress while you are the one and

33
00:01:55,810 --> 00:01:58,820
only thread running inside a monitor,

34
00:01:58,820 --> 00:02:02,390
then you can step outside the monitor
using what's called a condition.

35
00:02:02,390 --> 00:02:03,890
And you can wait for

36
00:02:03,890 --> 00:02:06,490
the condition expression you're
waiting on to become true.

37
00:02:08,050 --> 00:02:11,540
And then the third thing you can do
is you can notify other threads that

38
00:02:11,540 --> 00:02:14,270
conditions they're waiting
on may have been met.

39
00:02:15,440 --> 00:02:17,519
So that's a way to wake up
people who are waiting.

40
00:02:17,519 --> 00:02:19,685
So those are the three main
things a monitor does, and

41
00:02:19,685 --> 00:02:21,140
we'll talk more about this later.

42
00:02:22,330 --> 00:02:25,020
There's a bunch of human
known uses of monitors.

43
00:02:25,020 --> 00:02:29,678
One example that might be worthwhile to
think about is to make it more intuitive

44
00:02:29,678 --> 00:02:31,947
would be some kind of a hospital room.

45
00:02:31,947 --> 00:02:36,206
Like an operating room in a hospital where
you want to be able to allow people to

46
00:02:36,206 --> 00:02:39,154
queue up waiting to get
access to the operating room,

47
00:02:39,154 --> 00:02:40,810
which is a critical section.

48
00:02:40,810 --> 00:02:45,900
Let's say for hygienic purposes to
reduce the likelihood of infection,

49
00:02:45,900 --> 00:02:51,530
only one person, only one patient can
be in the operating room at a time.

50
00:02:51,530 --> 00:02:56,250
Of course, you can have multiple doctors,
but only one person could be in there.

51
00:02:56,250 --> 00:03:01,370
And they have to wait in a pre-operating
room outside of the critical section for

52
00:03:01,370 --> 00:03:03,200
their turn to come in.

53
00:03:03,200 --> 00:03:07,131
And after they're done, they can go to
a post-operating room to wait to leave.

54
00:03:07,131 --> 00:03:11,751
But only one patient is in
the operating room at a time.

55
00:03:11,751 --> 00:03:15,802
So, let's take a look at a simple example
to motivate why we need to have monitor

56
00:03:15,802 --> 00:03:16,349
objects.

57
00:03:16,349 --> 00:03:18,729
And we'll look at this in a couple
of different vantage points.

58
00:03:18,729 --> 00:03:25,370
The example here is based on
Java's ArrayBlockingQueue.

59
00:03:27,780 --> 00:03:31,696
And so, we'll take a look and
see how an ArrayBlockingQueue works.

60
00:03:31,696 --> 00:03:36,754
Here's a UML sequence diagram that
shows the design of our buggy solution,

61
00:03:36,754 --> 00:03:39,214
and you can find the buggy solution.

62
00:03:39,214 --> 00:03:42,109
If you like to run buggy code and
try to figure out why it's buggy,

63
00:03:42,109 --> 00:03:44,700
you can take a look at the code here for
the buggy solution.

64
00:03:45,950 --> 00:03:47,893
So, we have a main program.

65
00:03:47,893 --> 00:03:52,740
And that main program spawns two threads,
a producer thread and a consumer thread.

66
00:03:52,740 --> 00:03:56,026
Both of which access a simpleQueue.

67
00:03:56,026 --> 00:04:01,399
And then, when those threads start to run,
they alternate or they don't alternate.

68
00:04:01,399 --> 00:04:06,438
They both call put and
take on the simpleQueue concurrently.

69
00:04:06,438 --> 00:04:10,535
And, of course, we'll see in a second
that that causes all kinds of problems

70
00:04:10,535 --> 00:04:12,635
with respect to race conditions.

71
00:04:12,635 --> 00:04:17,437
Which are situations where you're
corrupting the internal state of an object

72
00:04:17,437 --> 00:04:21,001
by having multiple threads
simultaneously try to read and

73
00:04:21,001 --> 00:04:23,343
write its fields in unprotected way.

74
00:04:24,928 --> 00:04:28,210
Here's an example of
a simple BlockingQueue.

75
00:04:28,210 --> 00:04:30,124
It implements the BlockingQueue interface.

76
00:04:30,124 --> 00:04:34,870
And take a look here for
more information about BlockingQueue.

77
00:04:36,060 --> 00:04:39,600
It creates a resizable array
implementation called an ArrayList.

78
00:04:40,780 --> 00:04:43,020
You could read more about ArrayList here.

79
00:04:43,020 --> 00:04:46,840
And then, it has a pair of
non-synchronized public methods,

80
00:04:46,840 --> 00:04:48,310
put and take.

81
00:04:48,310 --> 00:04:50,260
And the idea is that these
are trying to add and

82
00:04:50,260 --> 00:04:51,730
remove the elements from the queue.

83
00:04:51,730 --> 00:04:54,960
It will add an element at the end and
take the element from the front.

84
00:04:54,960 --> 00:04:56,110
So that's what it's trying to do.

85
00:04:57,510 --> 00:04:59,220
Here's the main program.

86
00:04:59,220 --> 00:05:01,980
It goes ahead and
creates this SimpleQueue.

87
00:05:01,980 --> 00:05:05,850
It creates a pair of threads,
a producer and a consumer.

88
00:05:05,850 --> 00:05:08,525
It starts the producer and
consumer threads, and

89
00:05:08,525 --> 00:05:10,314
then those threads begin to run.

90
00:05:10,314 --> 00:05:15,302
As you can see, what they do when
they run is they sit there, and

91
00:05:15,302 --> 00:05:18,878
one thread will put a string to the queue,
and

92
00:05:18,878 --> 00:05:24,177
the other thread will go ahead and
take the string out of the queue.

93
00:05:24,177 --> 00:05:26,290
So that's what we're trying to do.

94
00:05:26,290 --> 00:05:33,750
We're trying to have the two threads
communicate through a SimpleQueue.

95
00:05:33,750 --> 00:05:37,540
The question, of course,
is what's the output of this program and

96
00:05:37,540 --> 00:05:38,980
why does it behave the way it does?

97
00:05:40,010 --> 00:05:42,604
Well, if you run this program,
you'll see it will do bad things.

98
00:05:42,604 --> 00:05:45,750
It will crash and
give you strange results and so on.

99
00:05:46,750 --> 00:05:48,280
And, the reason why, of course,

100
00:05:48,280 --> 00:05:50,870
it does that, is that,
there's several reasons why.

101
00:05:50,870 --> 00:05:54,750
But one of the reasons why is there's no
protection against the critical section,

102
00:05:54,750 --> 00:05:57,620
which is basically the part
that's the shared state,

103
00:05:57,620 --> 00:06:02,660
which is the list, being accessed
concurrently by multiple threads.

104
00:06:02,660 --> 00:06:04,840
And if you read the documentation for
ArrayList,

105
00:06:04,840 --> 00:06:09,690
you'll see it says that the implementation
of ArrayList is not synchronized.

106
00:06:09,690 --> 00:06:16,350
So, if multiple threads try to access it,
then it must be synchronized externally.

107
00:06:16,350 --> 00:06:19,560
And that, of course,
if what we're going to end up doing here

108
00:06:19,560 --> 00:06:22,760
because we're going to be ensuring that
we synchronize these things properly.

109
00:06:24,460 --> 00:06:26,576
So, the problem here has a funny name.

110
00:06:26,576 --> 00:06:28,770
It's a name called a race condition.

111
00:06:28,770 --> 00:06:34,110
And race conditions occur when you
have multiple threads accessing fields

112
00:06:34,110 --> 00:06:38,950
that are not protected by the proper
synchronization mechanisms.

113
00:06:40,270 --> 00:06:44,246
And this is a very tedious and
error-prone thing to try to address.

114
00:06:44,246 --> 00:06:48,554
And, it's why understanding patterns of
effective concurrent programming in Java

115
00:06:48,554 --> 00:06:52,261
is so important, especially if you're
writing Android code, where you

116
00:06:52,261 --> 00:06:56,360
almost have to have concurrent programs,
for reasons we'll talk about later.

117
00:06:57,930 --> 00:07:01,570
We're going to fix all these problems by
applying various built-in monitor object

118
00:07:01,570 --> 00:07:02,480
mechanisms in Java.

119
00:07:03,650 --> 00:07:05,200
And so,
let's start talking about those next.

120
00:07:06,370 --> 00:07:09,520
So, we're going to talk about how to
fix these problems using the several

121
00:07:09,520 --> 00:07:10,760
mechanisms that Java provides.

122
00:07:12,860 --> 00:07:16,630
Java provides a couple of different
built-in monitor object mechanisms.

123
00:07:16,630 --> 00:07:17,460
So, let's talk about them.

124
00:07:19,100 --> 00:07:23,270
All objects in Java can be
used as monitor objects.

125
00:07:23,270 --> 00:07:25,267
And they support two types
of thread synchronization.

126
00:07:25,267 --> 00:07:27,955
They support mutual exclusion,

127
00:07:27,955 --> 00:07:33,427
which allows concurrent access and
updates to shared data fields or

128
00:07:33,427 --> 00:07:38,800
data shared by threads without
incurring race conditions.

129
00:07:38,800 --> 00:07:40,899
So, they solve the issue of concurrency.

130
00:07:40,899 --> 00:07:44,780
And then,
there's also something else that they do.

131
00:07:44,780 --> 00:07:47,880
Oh, and they do this,
they support mutual exclusion

132
00:07:47,880 --> 00:07:50,950
via something that's called
synchronized methods or blocks.

133
00:07:52,480 --> 00:07:55,280
And, basically,
the synchronized methods and

134
00:07:55,280 --> 00:07:58,154
blocks use something
called the Entrance Queue.

135
00:07:58,154 --> 00:08:01,686
And, this is managed internally
by the Java virtual machine, and

136
00:08:01,686 --> 00:08:05,168
we'll talk a bit later on how that
actually works under the hood.

137
00:08:06,272 --> 00:08:11,930
Every Java object has a single so-called
intrinsic lock that's associated with it.

138
00:08:11,930 --> 00:08:14,700
And if you make a synchronized method or
a synchronized statement,

139
00:08:14,700 --> 00:08:17,570
it's that intrinsic lock that's
being acquired and released.

140
00:08:19,200 --> 00:08:21,080
And there's also something
called coordination.

141
00:08:21,080 --> 00:08:24,980
So, every monitor object
also supports coordination.

142
00:08:24,980 --> 00:08:28,670
And that enables threads to cooperatively
schedule their interactions, and

143
00:08:28,670 --> 00:08:32,140
it does this using something
called a wait queue.

144
00:08:32,140 --> 00:08:36,260
And the JVM supports coordination
via a wait queue and

145
00:08:36,260 --> 00:08:38,300
various notification mechanisms
that are built into it.

146
00:08:38,300 --> 00:08:40,160
And we'll talk later about how that works,
as well.

147
00:08:41,390 --> 00:08:46,180
Every job object has a single intrinsic
condition associated with it.

148
00:08:46,180 --> 00:08:50,020
So, there's a single intrinsic lock and
there's a single intrinsic condition.

149
00:08:50,020 --> 00:08:52,970
And that actually causes some issues for
which

150
00:08:52,970 --> 00:08:56,410
other Java synchronization mechanisms
are required, which we'll touch on later.

151
00:08:58,300 --> 00:09:00,910
These mechanisms implement a variant
of the monitor object pattern.

152
00:09:00,910 --> 00:09:03,430
We'll talk a lot about
patterns in this course.

153
00:09:03,430 --> 00:09:05,700
Take a look here, you can read more
about the monitor object pattern.

154
00:09:05,700 --> 00:09:08,290
You can also find out about this from

155
00:09:08,290 --> 00:09:12,200
the Pattern Oriented Software
Architecture Volume Two Book posted, too.

156
00:09:13,570 --> 00:09:17,440
The intent of this pattern is to ensure
that only one method runs within an object

157
00:09:17,440 --> 00:09:21,199
and to allow an object's methods to
cooperatively schedule their execution

158
00:09:21,199 --> 00:09:21,854
sequences.

159
00:09:21,854 --> 00:09:26,112
So, you can see the monitor
Object Pattern is obviously what

160
00:09:26,112 --> 00:09:29,293
Java's Monitor Objects are implementing.

161
00:09:29,293 --> 00:09:34,720
You can also implement monitor object
pattern in other languages besides Java,

162
00:09:34,720 --> 00:09:38,490
like C++, or C-sharp, or
C, or Ada, or whatever.

163
00:09:40,520 --> 00:09:44,260
We're going to use monitor objects to
implement a better solution to the buggy

164
00:09:44,260 --> 00:09:47,780
SimpleQueue and the inefficient
BusySynchronizedQueue solutions.

165
00:09:48,810 --> 00:09:50,410
So, we'll see how that's
all going to work.

166
00:09:52,420 --> 00:09:55,210
Let's first start by talking about
built-in synchronized methods.

167
00:09:55,210 --> 00:09:58,710
These are the most fundamental
part of Java monitor objects.

168
00:09:58,710 --> 00:10:02,120
They're very simple,
somewhat limited, but very simple.

169
00:10:02,120 --> 00:10:03,160
To show these things,

170
00:10:03,160 --> 00:10:06,060
we're going to have something
called the BusySynchronizedQueue.

171
00:10:06,060 --> 00:10:08,820
So this is a way to fix some of
the problems with the SimpleQueue

172
00:10:08,820 --> 00:10:09,580
that we had before.

173
00:10:10,730 --> 00:10:13,470
You can see the BusySsynchronizedQueue
here at this link.

174
00:10:14,890 --> 00:10:19,440
This thing is going to be able
to implement BlockingQueue,

175
00:10:19,440 --> 00:10:22,740
which has a certain set of interfaces we
expect, certain set of methods we expect.

176
00:10:23,900 --> 00:10:25,770
And it's going to have
some internal state,

177
00:10:25,770 --> 00:10:28,380
which is going to be the list and
the capacity.

178
00:10:28,380 --> 00:10:34,020
And those, we want to protect against race
conditions by using synchronized methods.

179
00:10:35,520 --> 00:10:36,500
Here's the constructor.

180
00:10:36,500 --> 00:10:38,230
It initializes the internal state.

181
00:10:39,360 --> 00:10:42,270
Here are the methods,
put, take, and isEmpty.

182
00:10:42,270 --> 00:10:43,900
All of these are marked as synchronized,

183
00:10:43,900 --> 00:10:46,440
and that means only one of
them can run at a time.

184
00:10:46,440 --> 00:10:47,630
And I'll show you how that works.

185
00:10:47,630 --> 00:10:49,567
Only one can run at
a time on a given object.

186
00:10:51,691 --> 00:10:56,672
So that means they're serialized with
respect to other synchronized methods

187
00:10:56,672 --> 00:10:57,920
on an object.

188
00:10:57,920 --> 00:10:58,970
And this is very important.

189
00:10:58,970 --> 00:11:03,370
If you have two different objects, each
of which has synchronized methods, and

190
00:11:03,370 --> 00:11:05,060
they're not static methods,

191
00:11:05,060 --> 00:11:08,810
then calls on those two different
objects can actually run in parallel.

192
00:11:08,810 --> 00:11:11,500
So it's only within
an object that matters.

193
00:11:12,510 --> 00:11:16,479
And you can think about synchronized
is basically a way to provide

194
00:11:16,479 --> 00:11:21,218
so-called fully-bracketed
access to a critical region.

195
00:11:21,218 --> 00:11:25,020
And fully-bracketed means
the thread that acquires the lock,

196
00:11:25,020 --> 00:11:28,390
the intrinsic lock,
to enter the critical section

197
00:11:28,390 --> 00:11:31,660
must be the thread that releases
the lock on the way out.

198
00:11:31,660 --> 00:11:34,907
That's what fully-bracketed means,
and we'll talk about how that works.

199
00:11:37,302 --> 00:11:40,439
When we use these in the method signature,

200
00:11:40,439 --> 00:11:44,720
the access to the entire body
of the method is serialized.

201
00:11:44,720 --> 00:11:46,394
So if we say synchronized here,

202
00:11:46,394 --> 00:11:49,997
this covers everything from open
curly brace to closed curly brace.

203
00:11:49,997 --> 00:11:53,464
We'll see later in a second that there
are other more fine-grained ways to

204
00:11:53,464 --> 00:11:54,134
handle this.

205
00:11:56,585 --> 00:11:59,725
The fine-grained ways, of course,
are called synchronized statements.

206
00:12:00,795 --> 00:12:03,523
As you can see in this example,
we're going to to look at here,

207
00:12:03,523 --> 00:12:06,803
which is actually from Java,
Java has something called the Exchanger.

208
00:12:06,803 --> 00:12:11,775
Synchronized methods can yield
excessive serialization overhead.

209
00:12:11,775 --> 00:12:16,160
So, here's an Exchanger, you can
find out more about Exchanger here.

210
00:12:16,160 --> 00:12:19,004
And what we have is
a method called createSlot,

211
00:12:19,004 --> 00:12:23,712
which is a synchronized method,
as you can see up here, it's synchronized.

212
00:12:23,712 --> 00:12:28,050
And inside of this,
the whole method is synchronized.

213
00:12:28,050 --> 00:12:29,718
And what's going to happen is we're
going to make ourselves a new slot.

214
00:12:29,718 --> 00:12:35,705
And then, we're going to check to see
if an item is initialized or not.

215
00:12:35,705 --> 00:12:38,019
And if it is not initialized,
we're going to initialize it.

216
00:12:38,019 --> 00:12:40,611
So, we're going to lazily create the slot,

217
00:12:40,611 --> 00:12:45,995
if it's the first time that it's accessed,
and this whole method is synchronized.

218
00:12:45,995 --> 00:12:46,885
Which means that,

219
00:12:46,885 --> 00:12:51,465
that entire chunk of code can only have
one thread operate on it at a time.

220
00:12:53,270 --> 00:12:56,792
That turns out to be excessive,
that's more lock-in than we really need,

221
00:12:56,792 --> 00:12:57,900
in this case.

222
00:12:57,900 --> 00:13:00,830
So here is another example
of rewriting this method.

223
00:13:00,830 --> 00:13:06,730
And instead of having synchronized be
part of the signature, instead, we move

224
00:13:06,730 --> 00:13:12,410
synchronized into just the portion of
the method that really needs to be locked.

225
00:13:12,410 --> 00:13:15,210
And this is what's called a synchronized
statement or a synchronized block.

226
00:13:16,350 --> 00:13:18,010
You can read more about
it here at this link.

227
00:13:19,620 --> 00:13:22,895
Synchronized statements are important
because they enable more fine-grained

228
00:13:22,895 --> 00:13:24,950
serialization than synchronized methods,
because we

229
00:13:26,090 --> 00:13:29,920
only need to synchronize a particular
region in a method, not the whole method.

230
00:13:29,920 --> 00:13:34,220
So, for example in this case, these
calls here, where we make a new slot and

231
00:13:34,220 --> 00:13:39,380
we assign an arena to
the local variable a here,

232
00:13:39,380 --> 00:13:44,150
these are actually not synchronized.

233
00:13:44,150 --> 00:13:47,880
I should probably put the word
final before them as well, but

234
00:13:47,880 --> 00:13:51,220
I don't think the Java code
had that when I looked at it.

235
00:13:51,220 --> 00:13:54,080
So, basically,
we're creating a slot outside of the lock

236
00:13:54,080 --> 00:13:57,150
to narrow the region in which
synchronization has to be performed.

237
00:13:57,150 --> 00:14:00,690
And that will help us
get higher concurrency,

238
00:14:00,690 --> 00:14:02,030
especially on a multi-core processor.

239
00:14:03,150 --> 00:14:05,060
So, only this statement here,

240
00:14:05,060 --> 00:14:08,170
within the curly braces,
is serialized by the intrinsic lock.

241
00:14:09,210 --> 00:14:10,610
So this is using the intrinsic lock.

242
00:14:10,610 --> 00:14:11,754
We can also use other kinds of things.

243
00:14:11,754 --> 00:14:16,050
We can explicitly synchronize
with another object.

244
00:14:16,050 --> 00:14:19,418
Every Java object,
it's not a built-in type.

245
00:14:19,418 --> 00:14:23,230
Built-in types would be things like
double, int, float, and so on.

246
00:14:23,230 --> 00:14:26,570
Every Java object can
be used to synchronize,

247
00:14:26,570 --> 00:14:30,070
because every Java object has
an intrinsic lock that's part of it.

248
00:14:30,070 --> 00:14:33,879
We would normally say
synchronize this here, but

249
00:14:33,879 --> 00:14:39,512
we could also say synchronize on a,
which is this arena object down here.

250
00:14:39,512 --> 00:14:42,967
We also see something called
the double-checked locking optimization

251
00:14:42,967 --> 00:14:44,470
pattern.

252
00:14:44,470 --> 00:14:46,850
I'm not going to go into
too much detail right now.

253
00:14:46,850 --> 00:14:47,845
But if you read this link,

254
00:14:47,845 --> 00:14:50,532
you'll find out more about
double-checked locking optimization.

255
00:14:50,532 --> 00:14:52,730
And that's basically what this
code is implementing here.

256
00:14:57,920 --> 00:15:01,680
Okay, so you can read more about
synchronized statements here at this link.

257
00:15:01,680 --> 00:15:03,520
I highly recommend you do it.

258
00:15:03,520 --> 00:15:06,530
You'll have to understand how these things
work in order to do the programming

259
00:15:06,530 --> 00:15:07,670
assignments in the course.

260
00:15:07,670 --> 00:15:10,390
So, you might as well take some
time to read more about it and

261
00:15:10,390 --> 00:15:13,180
ask questions on the discussion forum.

262
00:15:13,180 --> 00:15:15,310
So armed with what we know now,

263
00:15:15,310 --> 00:15:19,540
let's now take a look at a partial
solution using Java synchronized methods.

264
00:15:20,610 --> 00:15:22,140
So this is going to be a partial solution,
so

265
00:15:22,140 --> 00:15:23,731
it's not going to solve all the problems.

266
00:15:23,731 --> 00:15:27,560
Here's our BusySynchronizedQueue example.

267
00:15:27,560 --> 00:15:33,300
As you can see here, we have
synchronized keyword put on take and

268
00:15:33,300 --> 00:15:36,970
put, which means that those
things are serialized.

269
00:15:36,970 --> 00:15:41,000
Only one synchronized method could be
active at a time in a given object.

270
00:15:42,730 --> 00:15:46,255
And adding the synchronized
keyword either in the method or

271
00:15:46,255 --> 00:15:49,019
in a synchronized
statement has two effects.

272
00:15:49,019 --> 00:15:52,432
The first effect is that
invocations of put and

273
00:15:52,432 --> 00:15:55,681
take on the same object can't interleave.

274
00:15:55,681 --> 00:15:58,430
What that means is that
they run atomically.

275
00:15:58,430 --> 00:16:01,330
Put runs to completion before take runs,
or

276
00:16:01,330 --> 00:16:03,550
take runs to completion before put runs.

277
00:16:03,550 --> 00:16:07,060
But we don't have to worry about
them running a little bit of put and

278
00:16:07,060 --> 00:16:08,900
a little bit of take at the same time.

279
00:16:08,900 --> 00:16:11,150
That's one thing that happens.

280
00:16:11,150 --> 00:16:13,510
So this means that each method is atomic.

281
00:16:13,510 --> 00:16:17,420
So if one call to put is
running then a call to take, or

282
00:16:17,420 --> 00:16:20,620
another call to put by different
threads will have to block.

283
00:16:20,620 --> 00:16:22,420
So, that's a way to think about it.

284
00:16:22,420 --> 00:16:27,160
And a second thing that happens is
there's a happens before relationship

285
00:16:27,160 --> 00:16:32,130
that ensures when we add something over
here, when one thread adds something

286
00:16:32,130 --> 00:16:37,440
to the list over here, Tthat that will
be properly propagated over here.

287
00:16:37,440 --> 00:16:42,460
So there will not be inconsistent or
misordered access to memory.

288
00:16:42,460 --> 00:16:47,940
Because, synchronized statements will
flush out the caches as things change.

289
00:16:50,710 --> 00:16:54,210
There are some limitations of
Java synchronized methods, and

290
00:16:54,210 --> 00:16:58,180
that's important to understand what
we're about to talk about next.

291
00:16:58,180 --> 00:17:01,242
So, if we only use them and
we don't do anything else,

292
00:17:01,242 --> 00:17:05,171
we just use synchronize methods or
blocks, then calls to these put and

293
00:17:05,171 --> 00:17:09,650
take methods will busy wait, and
that can lead to all kinds of problems.

294
00:17:09,650 --> 00:17:15,670
The most obvious problem with busy
waiting is that you'll waste CPU cycles,

295
00:17:15,670 --> 00:17:19,410
spinning, doing nothing useful,
like a hamster or

296
00:17:19,410 --> 00:17:23,940
a gerbil in a little running wheel.

297
00:17:23,940 --> 00:17:25,380
So, that's a bad use of things.

298
00:17:25,380 --> 00:17:29,190
There are also potentially problems
with starvation here as well.

299
00:17:29,190 --> 00:17:31,630
But basically spinning is a bad idea for

300
00:17:31,630 --> 00:17:35,270
stuff like this, unless you're
building a hard real-time system to

301
00:17:35,270 --> 00:17:40,610
do something like control
the temperature in a nuclear reactor, or

302
00:17:40,610 --> 00:17:44,580
modify the flight services on an airplane
control wing, or something like that.

303
00:17:47,180 --> 00:17:50,006
So what we need to do,
instead of just busy waiting,

304
00:17:50,006 --> 00:17:54,247
is we need to have some vehicle, some
mechanism, to coordinate put and take so

305
00:17:54,247 --> 00:17:56,974
they don't busy wait when
there is nothing to do.

306
00:17:56,974 --> 00:18:01,751
And, of course, the way to do that,
which we'll talk about in a minute,

307
00:18:01,751 --> 00:18:05,913
is to use the wait and
notify mechanisms provided by Java monitor

308
00:18:05,913 --> 00:18:09,710
objects to provide a convenient and
efficient solution.

