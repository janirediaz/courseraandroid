1
00:00:00,890 --> 00:00:05,585
The next topic we're going to cover goes
a bit more in depth about managing various

2
00:00:05,585 --> 00:00:07,846
aspects of the Java thread lifecycle.

3
00:00:07,846 --> 00:00:10,043
So we're going to talk about what
the Java thread lifecycle is,

4
00:00:10,043 --> 00:00:11,996
we're going to talk about how
to manage it effectively.

5
00:00:11,996 --> 00:00:17,525
The main focus of this discussion really
deals with learning how to stop or

6
00:00:17,525 --> 00:00:20,565
interrupt Java threads, gracefully.

7
00:00:20,565 --> 00:00:24,041
We'll first start by talking about
the different states in the Java thread

8
00:00:24,041 --> 00:00:24,657
lifecycle.

9
00:00:24,657 --> 00:00:28,310
A thread, as you might imagine is actually
a very complicated entity that interacts

10
00:00:28,310 --> 00:00:31,610
with lots other things, both at
the hardware level and the software level.

11
00:00:33,060 --> 00:00:36,920
And so you have to know how these threads
works, the state of the threads and

12
00:00:36,920 --> 00:00:39,750
you have to understand how to manage
their lifecycle very carefully.

13
00:00:40,830 --> 00:00:43,472
So there's about seven
different states and

14
00:00:43,472 --> 00:00:45,702
we're going to talk about each of them.

15
00:00:45,702 --> 00:00:50,138
Two of the most important parts of Java
involve starting and stopping threads, so

16
00:00:50,138 --> 00:00:52,660
we're going to pay
particular emphasis there.

17
00:00:54,600 --> 00:00:56,014
To use Java threads effectively,

18
00:00:56,014 --> 00:00:59,184
you don't have to understand all
the inner details we're about to discuss,

19
00:00:59,184 --> 00:01:02,175
that's only for people who want to
have sort of wizard level knowledge.

20
00:01:02,175 --> 00:01:05,234
But it doesn't hurt to have
a good understanding of these,

21
00:01:05,234 --> 00:01:09,703
because you'll often run into situations
where your concurrent programs don't work

22
00:01:09,703 --> 00:01:10,437
correctly and

23
00:01:10,437 --> 00:01:14,782
knowing how the threads transition between
different states in there lifecycle can

24
00:01:14,782 --> 00:01:18,540
help you with debugging various defects
that have crept into your code.

25
00:01:18,540 --> 00:01:23,340
We'll start by talking about
the state machine for Java threads.

26
00:01:23,340 --> 00:01:26,091
As you can see,
there's again seven main states.

27
00:01:26,091 --> 00:01:28,730
You can see the states
here in the documentation.

28
00:01:28,730 --> 00:01:33,053
There's also a nice UML diagram that gives
you another more visual view of these

29
00:01:33,053 --> 00:01:34,999
states then what I've shown here.

30
00:01:34,999 --> 00:01:39,185
When you create a thread,
when you say, new thread object,

31
00:01:39,185 --> 00:01:41,743
new my thread or new thread, etc..

32
00:01:41,743 --> 00:01:44,653
That transitions the state
machine to the new state,

33
00:01:44,653 --> 00:01:47,960
which just allocates a few resources for
the thread object.

34
00:01:49,190 --> 00:01:54,180
When you start the thread, that completes
the initialization by creating more

35
00:01:54,180 --> 00:01:57,880
resource intensive
objects like a stack and

36
00:01:57,880 --> 00:02:01,590
that then makes the thread
transition into the runnable state.

37
00:02:01,590 --> 00:02:05,300
Now just because you say start,
doesn't mean the threads actually running.

38
00:02:05,300 --> 00:02:09,890
All it means is that it's able to run and
it's the schedule that decides whether or

39
00:02:09,890 --> 00:02:11,260
not to run the threads and
when to run them.

40
00:02:12,470 --> 00:02:16,450
When a schedule selects a runnable
thread to run, it begins to run and

41
00:02:16,450 --> 00:02:19,440
that is the run hook
method gets called back.

42
00:02:21,070 --> 00:02:25,790
If during the running of the run hook
method, the thread sleeps, waits or

43
00:02:25,790 --> 00:02:30,400
joins with operations that have
a time out associated with them,

44
00:02:30,400 --> 00:02:33,400
that transitions to
the timed waiting state.

45
00:02:33,400 --> 00:02:38,136
And the thread will then, basically,
be deactivated until the time period

46
00:02:38,136 --> 00:02:41,026
elapses or
whatever else it's doing occurs.

47
00:02:41,026 --> 00:02:45,744
Like if the wait If it's notified or is,
it's the other thread its going to join

48
00:02:45,744 --> 00:02:50,173
with, it's going to be exited,
et cetera, then it'll transition out

49
00:02:50,173 --> 00:02:54,430
of the timed waiting state and
it becomes runnable again.

50
00:02:54,430 --> 00:02:57,252
But again, it doesn't start running,
it just becomes runnable.

51
00:02:57,252 --> 00:02:58,770
So let's say, it's running again.

52
00:02:59,890 --> 00:03:04,672
Run methods called and now it attempts
to access a so-called guarded resource

53
00:03:04,672 --> 00:03:08,453
such as the intrinsic lock that's
part of every Java object.

54
00:03:08,453 --> 00:03:10,190
We'll talk more about that later.

55
00:03:10,190 --> 00:03:13,595
So it tries to do that,
it tries to enter a synchronized method or

56
00:03:13,595 --> 00:03:14,865
a synchronized block.

57
00:03:14,865 --> 00:03:18,800
And if that is in use,
that will cause it to become blocked.

58
00:03:20,050 --> 00:03:21,260
In which case,

59
00:03:21,260 --> 00:03:24,910
it will remain blocked until it is able
to acquire the resource that it needs.

60
00:03:26,010 --> 00:03:29,780
And once it becomes acquiring
the resource, like it grabs the lock, it's

61
00:03:29,780 --> 00:03:34,070
not ready to run again and the scheduler
will start at running at some point.

62
00:03:35,220 --> 00:03:39,320
It then may also call
the cond.wait() method, which is

63
00:03:40,370 --> 00:03:44,210
wait method that's part of the condition
that's part of every Java object.

64
00:03:44,210 --> 00:03:47,000
We'll talk more about that shortly,
as well and

65
00:03:47,000 --> 00:03:51,920
that causes it to go into the waiting
state and it remains in that state and

66
00:03:51,920 --> 00:03:56,190
becomes deactivated Until
someone notifies it.

67
00:03:56,190 --> 00:04:00,250
So it notifies it either by calling notify
or by calling notifyAll and that will wake

68
00:04:00,250 --> 00:04:04,840
it up, put it back in the runnable and
then it can start to run again.

69
00:04:04,840 --> 00:04:09,562
While it's running, if it terminates for
some reason, either it decides it's done

70
00:04:09,562 --> 00:04:12,720
and it exits the run method or
an exception has occurred.

71
00:04:12,720 --> 00:04:16,340
Either one, it then transitions
to the terminated state.

72
00:04:16,340 --> 00:04:19,220
And from that point on,
it can be basically shut down.

73
00:04:21,970 --> 00:04:26,740
Let's go a little bit deeper now talking
about how we start and stop Java threads.

74
00:04:26,740 --> 00:04:30,390
So we'll begin by discussing
how we start a Java thread.

75
00:04:31,460 --> 00:04:34,880
So starting a Java thread involves
some very interesting design and

76
00:04:34,880 --> 00:04:37,150
implementation issues.

77
00:04:37,150 --> 00:04:42,090
Calling start() on a thread, causes it
to start executing its run hook method.

78
00:04:43,260 --> 00:04:47,640
And this actually triggers many,
many steps in the Java middleware,

79
00:04:47,640 --> 00:04:50,220
virtual machine, and
operating system layer.

80
00:04:50,220 --> 00:04:53,240
And if you're running on Android, there's
even a few more steps involved as well.

81
00:04:54,650 --> 00:04:55,750
So the key thing to note here,

82
00:04:55,750 --> 00:04:58,790
I'm about to talk about these steps,
but the key thing to remember is that

83
00:04:58,790 --> 00:05:03,440
starting a thread consumes
a non-trivial amount of resources.

84
00:05:03,440 --> 00:05:07,680
So you've got to be prepared to understand
that you don't want to start threads just

85
00:05:09,170 --> 00:05:11,830
haphazardly, you want to do it for
a reason and

86
00:05:11,830 --> 00:05:15,820
usually that reason is you've got some
fairly long running computations that

87
00:05:15,820 --> 00:05:17,290
make it worthwhile to start the threads.

88
00:05:18,700 --> 00:05:21,776
You can go here and
find all the Java source code.

89
00:05:21,776 --> 00:05:25,395
This is sort of my shorthand to say,
here's the link and

90
00:05:25,395 --> 00:05:29,220
then just replace this part
here with the session number.

91
00:05:29,220 --> 00:05:34,068
Which in this case, would be 003 for this
current session that'll be how you can

92
00:05:34,068 --> 00:05:37,810
find that particular location
after you find the source code for

93
00:05:37,810 --> 00:05:40,531
all of the things you're
about to talk about.

94
00:05:40,531 --> 00:05:44,740
So let's say, a thread says,
myThread.start().

95
00:05:44,740 --> 00:05:49,310
Underneath the hood, that will then
call down to the Thread.start method,

96
00:05:49,310 --> 00:05:53,480
which is part of Java and that will
then call into the virtual machine.

97
00:05:53,480 --> 00:05:55,620
Thread create method,
which is a native method.

98
00:05:56,950 --> 00:05:58,003
That on Android,

99
00:05:58,003 --> 00:06:02,505
then calls into another native method
that's part of the Android runtime.

100
00:06:02,505 --> 00:06:06,952
If you're using Dalvik, it's part of
the Dalvik runtime or if you're using Art,

101
00:06:06,952 --> 00:06:11,078
it's part of the Art runtime and so on and
this would be a native method call and

102
00:06:11,078 --> 00:06:14,345
then that will call even further
down to some other methods.

103
00:06:14,345 --> 00:06:19,553
And then finally, these methods
will call the underlying Linux,

104
00:06:19,553 --> 00:06:22,534
Android, pthread_create method.

105
00:06:22,534 --> 00:06:26,002
And pthread_create as we can see here,

106
00:06:26,002 --> 00:06:32,140
passes in some instructions to say,
how to start the thread.

107
00:06:32,140 --> 00:06:36,294
And it passes in a method
called interpThreadStart and

108
00:06:36,294 --> 00:06:41,442
interpThreadStart is actually c
function pointer that'll be used

109
00:06:41,442 --> 00:06:47,222
as the entry point into the new thread
that's being created with the runtime

110
00:06:47,222 --> 00:06:52,934
thread stack that was created by
the operating system in virtual machine.

111
00:06:52,934 --> 00:06:57,761
InterpThreadStart in turn is
an Android internal method that

112
00:06:57,761 --> 00:07:01,207
turns around and
calls backup to your code.

113
00:07:01,207 --> 00:07:02,281
And finally,

114
00:07:02,281 --> 00:07:09,100
the run hook method is called back on the
object that invoked start to begin with.

115
00:07:09,100 --> 00:07:11,380
So as you can see, it is a whole bunch
of steps that are going on here.

116
00:07:12,950 --> 00:07:16,601
And your mileage may vary a little bit
if you run a different operating system

117
00:07:16,601 --> 00:07:20,667
besides Android or if you run a different
version of Android that I'm showing here.

118
00:07:20,667 --> 00:07:23,353
There may be a few minor differences, but

119
00:07:23,353 --> 00:07:26,748
the basic overall flow will be more or
less the same.

120
00:07:29,119 --> 00:07:32,148
Let's now start discussing
how we stop Java threads and

121
00:07:32,148 --> 00:07:36,220
we're going to see there's a couple of
different ways to stop Java threads.

122
00:07:37,570 --> 00:07:38,828
So as it turns out,

123
00:07:38,828 --> 00:07:43,414
stopping Java threads is a lot more
complicated than starting them.

124
00:07:43,414 --> 00:07:49,320
And for those of you who have ever watched
the famous Disney movie, Fantasia.

125
00:07:49,320 --> 00:07:53,120
There's a great clip called
The Sorcerer's Apprentice and

126
00:07:53,120 --> 00:07:58,198
it illustrates the complexity of trying
to stop things once they're in motion.

127
00:07:58,198 --> 00:08:00,888
So if you replace threads
with broomsticks,

128
00:08:00,888 --> 00:08:06,380
you'll have basically the idea that's
going on with The Sorcerer's Apprentice.

129
00:08:06,380 --> 00:08:10,580
The Sorcerer's Apprentice, which is Mickey
Mouse creates a bunch of broomsticks to do

130
00:08:10,580 --> 00:08:14,286
the work for him and then the broomsticks
turn out to be very hard to shut down.

131
00:08:14,286 --> 00:08:17,720
So that's kind of the metaphor to think
about as we're discussing these features.

132
00:08:18,910 --> 00:08:23,458
It turns out that there's no
way in Java to safely and

133
00:08:23,458 --> 00:08:30,150
involuntarily stop a Java thread, you
can't do that and there's a description

134
00:08:30,150 --> 00:08:35,100
here why this is such a thorny
problem in the Java concurrency model.

135
00:08:36,460 --> 00:08:40,950
So what that means is if you want
to have operations that run for

136
00:08:40,950 --> 00:08:43,530
a long time in a separate thread,

137
00:08:43,530 --> 00:08:48,010
they have to be coded specifically
to stop themselves voluntarily.

138
00:08:49,310 --> 00:08:52,070
So there's one way to do
this is to use a stop flag.

139
00:08:52,070 --> 00:08:56,644
So here's an example where we've got
a class called MyRunnable that implements

140
00:08:56,644 --> 00:08:57,323
Runnable.

141
00:08:57,323 --> 00:08:59,179
We've got a method called run,

142
00:08:59,179 --> 00:09:03,390
we've got a loop in here that's
checking some long running operation.

143
00:09:04,450 --> 00:09:11,441
As you can see here, what we do is we have
a volatile Boolean called mIsStopped.

144
00:09:11,441 --> 00:09:15,900
It's set to false initially and
as long as it's not true, we keep running.

145
00:09:17,260 --> 00:09:20,650
And as you can see,
this is defined as volatile.

146
00:09:20,650 --> 00:09:24,810
You can take a look at this link for
more information about volatile.

147
00:09:24,810 --> 00:09:31,104
In a nutshell, a volatile is
a type qualifier that indicates in

148
00:09:31,104 --> 00:09:37,044
Java that any changes to that
variable are consistently and

149
00:09:37,044 --> 00:09:42,174
visibly propagated to
other threads atomically.

150
00:09:42,174 --> 00:09:46,264
So an easy way to think about this
is irrespective of whether or

151
00:09:46,264 --> 00:09:48,152
not you have a multi-core or

152
00:09:48,152 --> 00:09:53,347
multi-processor machine with different
memory that's local to each core or

153
00:09:53,347 --> 00:09:57,912
processor when you use of a volatile
variable, whatever you read and

154
00:09:57,912 --> 00:10:03,025
write to it, it bypasses any caches that
you may have in a core or processor and

155
00:10:03,025 --> 00:10:08,926
goes directly to the global memory and it
reads or writes directly to global memory.

156
00:10:08,926 --> 00:10:13,963
So that makes it certain that
the information is propagated

157
00:10:13,963 --> 00:10:18,807
consistently and
visibly to other threads atomically.

158
00:10:18,807 --> 00:10:23,100
We also add a method called stopMe,
that sets mIsStopped to true.

159
00:10:23,100 --> 00:10:25,898
And when mIsStopped is set to true,

160
00:10:25,898 --> 00:10:30,935
then the thread down here that's
running run will detect that as

161
00:10:30,935 --> 00:10:36,550
long as it remembers to check whether
mIsStopped is true or is not true.

162
00:10:36,550 --> 00:10:39,543
If you don't have that check there,
of course, you'll keep running for

163
00:10:39,543 --> 00:10:42,360
an indefinite period of time,
which is not at all what you want to do.

164
00:10:45,470 --> 00:10:50,347
So this solution using volatile
variables is very, very lightweight, but

165
00:10:50,347 --> 00:10:54,549
it's not integrated into
the underlying Java virtual machine.

166
00:10:54,549 --> 00:10:59,099
Which is somewhat problematic,
because certain things can't be tested for

167
00:10:59,099 --> 00:11:00,520
this way.

168
00:11:00,520 --> 00:11:04,732
In particular,
any blocking operations, reads,

169
00:11:04,732 --> 00:11:08,477
blocking rates, weights, joins, sleeps.

170
00:11:08,477 --> 00:11:13,660
All those other things won't be awakened
by the means we just described here,

171
00:11:13,660 --> 00:11:18,216
which could impede the shutdown
processing in your applications for

172
00:11:18,216 --> 00:11:20,040
a very long period of time.

173
00:11:20,040 --> 00:11:23,732
So that's not a good way to go.

174
00:11:23,732 --> 00:11:26,955
Now let's talk about how to stop Java
threads using interrupt request.

175
00:11:28,605 --> 00:11:32,685
A thread can be stopped by calling its
interrupt method and you can read more

176
00:11:32,685 --> 00:11:35,855
about interrupt here and I'll explain the
key points, but it's really good idea to

177
00:11:35,855 --> 00:11:37,905
read the documentation,
because it's kind of subtle.

178
00:11:39,165 --> 00:11:41,255
When you call interrupt,

179
00:11:41,255 --> 00:11:44,845
this posts something called
an interrupt request to a thread.

180
00:11:46,390 --> 00:11:49,140
And interrupts are implemented
by an internal

181
00:11:50,310 --> 00:11:52,380
flag that's called
the interrupt status flag.

182
00:11:53,860 --> 00:11:58,400
And when you invoke Thread.interrupt()
that sets the flag.

183
00:11:58,400 --> 00:12:03,002
So, that sets the flag or
whatever thread you've just interrupted.

184
00:12:03,002 --> 00:12:08,084
There are two different accessor methods
that can be used to check this flag and

185
00:12:08,084 --> 00:12:11,400
each one has different side
effects on the status.

186
00:12:11,400 --> 00:12:15,754
The is interrupted method as we'll see,
just checks and does not clear the status.

187
00:12:15,754 --> 00:12:19,011
The interrupted method checks and
clears the status and sometimes,

188
00:12:19,011 --> 00:12:21,760
it's confusing to know which one to use.

189
00:12:21,760 --> 00:12:22,660
We'll talk about that in a second.

190
00:12:24,050 --> 00:12:28,646
Here's a very simple program that starts,
runs and interrupts a background thread.

191
00:12:28,646 --> 00:12:34,990
So we have a main program here, which
goes ahead and creates a new Thread t1.

192
00:12:34,990 --> 00:12:38,817
And it does a bunch of work, we'll look
at that in a second and it's runnable.

193
00:12:38,817 --> 00:12:42,569
And then down here, we start the thread,
which we'll go ahead and

194
00:12:42,569 --> 00:12:47,126
follow those steps we discussed earlier
and then the run method will be called and

195
00:12:47,126 --> 00:12:48,650
it'll start to do work.

196
00:12:48,650 --> 00:12:52,153
It'll loop around and do stuff and calling
these methods, we'll look at more in

197
00:12:52,153 --> 00:12:54,997
detail in a second and
that'll start running in the background.

198
00:12:54,997 --> 00:12:56,160
And at some point,

199
00:12:56,160 --> 00:13:00,891
the main thread will decide it wants to
interrupt the background thread and so

200
00:13:00,891 --> 00:13:04,410
we'll take a look and
see what happens when that occurs.

201
00:13:06,010 --> 00:13:12,060
Internally, the run method of
the background thread calls methods that

202
00:13:12,060 --> 00:13:17,050
have to check periodically to see if the
thread that is running has been stopped.

203
00:13:17,050 --> 00:13:18,898
So there's a couple of
different options here.

204
00:13:18,898 --> 00:13:19,820
Let's take a look at both options.

205
00:13:21,260 --> 00:13:26,542
If you have threads that block in
various library calls and system calls,

206
00:13:26,542 --> 00:13:31,144
then those library calls,
assistant calls will automatically

207
00:13:31,144 --> 00:13:35,401
check to see if whether or
not the interrupt has occurred and

208
00:13:35,401 --> 00:13:40,623
will take the appropriate reaction,
typically through an exception.

209
00:13:40,623 --> 00:13:45,065
So here's an example where you
might call sleep or wait or

210
00:13:45,065 --> 00:13:49,145
certain kinds of blocking I/O calls or
join, etc.

211
00:13:49,145 --> 00:13:52,778
These are all things that block and
the operating system,

212
00:13:52,778 --> 00:13:57,303
the Java virtual machine will
automatically detect when that thread has

213
00:13:57,303 --> 00:14:01,827
been interrupted and it'll end up
generating interrupted exception,

214
00:14:01,827 --> 00:14:06,669
which you're then obliged to catch and
do something with to clean things up.

215
00:14:06,669 --> 00:14:09,376
So for blocking operations,
that's the way you do it.

216
00:14:09,376 --> 00:14:13,319
For non-blocking operations,
you have to periodically check to see if

217
00:14:13,319 --> 00:14:17,143
the interrupt has been called,
if thread interrupt has been called.

218
00:14:18,450 --> 00:14:19,870
Better to fix the bugs now and

219
00:14:19,870 --> 00:14:23,170
get them into the updated slide
deck than have them lurk around.

220
00:14:24,220 --> 00:14:27,180
So [COUGH] if a thread
interrupt has been called,

221
00:14:27,180 --> 00:14:30,300
then there's a couple ways to check.

222
00:14:30,300 --> 00:14:36,160
One way to do this is to call
Thread.interrupted and Thread.interrupted

223
00:14:36,160 --> 00:14:40,030
returns true, if an interrupt request
has been received by the thread.

224
00:14:41,070 --> 00:14:45,200
And whenever you call it,
it clears the interrupt status, so

225
00:14:45,200 --> 00:14:47,050
it's only good to call that one time.

226
00:14:49,050 --> 00:14:50,261
And a typical thing to do,

227
00:14:50,261 --> 00:14:53,242
if you're interrupted is to
throw the interrupted exception.

228
00:14:53,242 --> 00:14:56,988
Another thing you can do is you can use
the isInterrupted method and this method

229
00:14:56,988 --> 00:15:00,617
has to be called on a specific thread,
you can't call it on a static method,

230
00:15:00,617 --> 00:15:04,145
you have to call it on
a specific instance of a thread.

231
00:15:04,145 --> 00:15:07,762
And this returns true,
if an interrupt request has been received.

232
00:15:07,762 --> 00:15:12,884
However, it doesn't clear the interrupt
status, so that status is

233
00:15:12,884 --> 00:15:18,470
still available and you can come back and
call this method multiple times.

234
00:15:21,060 --> 00:15:25,220
All of these methods can actually be
overridden and you'll actually see,

235
00:15:25,220 --> 00:15:28,180
if you take a look at various
other parts of the course,

236
00:15:28,180 --> 00:15:31,240
you'll see some examples of this,
but it's rather rare and

237
00:15:31,240 --> 00:15:35,040
you have to really know what you're doing
in order to override the methods here.

238
00:15:35,040 --> 00:15:38,149
Here's a link that you can read more
about how and when you should do this.

239
00:15:41,899 --> 00:15:47,060
So here's a few things to remember when
we talk about interrupting Java threads.

240
00:15:47,060 --> 00:15:50,509
Java thread interrupts don't behave
like traditional hardware or

241
00:15:50,509 --> 00:15:52,149
operating system interrupts.

242
00:15:52,149 --> 00:15:54,739
You can read more about
what an interrupt is here.

243
00:15:54,739 --> 00:15:56,396
They're actually quite different.

244
00:15:56,396 --> 00:16:01,822
The Java interrupts are delivered
synchronously and non-preemptively,

245
00:16:01,822 --> 00:16:06,242
which means that the thread has
to be prepared to handle them.

246
00:16:06,242 --> 00:16:09,890
They don't just get
handled asynchronously.

247
00:16:09,890 --> 00:16:13,750
In contrast, hardware interrupts or
more traditional Unix signals,

248
00:16:13,750 --> 00:16:16,532
which are basically
software-like interrupts.

249
00:16:16,532 --> 00:16:21,720
Those types of interrupts
are asynchronous and preemptive.

250
00:16:21,720 --> 00:16:24,165
So you'd have no choice often,
but to handle them.

251
00:16:24,165 --> 00:16:27,478
In contrast, Java thread interrupts
are not asynchronous and

252
00:16:27,478 --> 00:16:28,860
they are not preemptive.

253
00:16:29,995 --> 00:16:32,371
Therefore, you have to test for
them explicitly.

254
00:16:32,371 --> 00:16:36,512
And usually, you throw the interrupted
exception and that's thrown

255
00:16:36,512 --> 00:16:40,864
synchronously and must be handled
synchronously by the calling thread or

256
00:16:40,864 --> 00:16:44,885
by the calling logic in the thread
that's throwing the exception.

257
00:16:44,885 --> 00:16:48,890
There's a number of patterns for
dealing with Java thread,

258
00:16:48,890 --> 00:16:54,030
InterruptedException and so
you'd take a look at this link here.

259
00:16:54,030 --> 00:16:59,160
There's a number of things you can do to
program it, program exceptions properly.

260
00:16:59,160 --> 00:17:04,004
One thing to do is just simply make
the interrupted exception be part of

261
00:17:04,004 --> 00:17:08,440
the exception specifier on a method and
don't worry about it and

262
00:17:08,440 --> 00:17:12,977
just let the caller of the method
be responsible for handling it.

263
00:17:12,977 --> 00:17:14,080
So that's one approach.

264
00:17:14,080 --> 00:17:18,085
So the caller or callers must then
handle the exception properly,

265
00:17:18,085 --> 00:17:21,962
you'll see lots of examples of
that as we go through the course.

266
00:17:21,962 --> 00:17:25,471
Another thing to do is to
catch the exception and

267
00:17:25,471 --> 00:17:30,940
then perform some specific cleanup
operation and then re-throw it.

268
00:17:30,940 --> 00:17:35,749
So here's an example where we're waiting
for something and if an interrupt occurs,

269
00:17:35,749 --> 00:17:39,487
we want to clear out some information
that we stored in the queue and

270
00:17:39,487 --> 00:17:41,320
then re-throw the exception.

271
00:17:41,320 --> 00:17:43,769
The idea here is to avoid
leaking resources or

272
00:17:43,769 --> 00:17:46,480
leaving the resources in
an inconsistent state.

273
00:17:48,150 --> 00:17:51,700
Yet, another thing to do is
to catch an exception and

274
00:17:51,700 --> 00:17:56,070
then restore the interrupt exception
status by calling interrupt again.

275
00:17:56,070 --> 00:17:59,560
That way,
even if you're not going to handle it,

276
00:17:59,560 --> 00:18:04,898
you can push it up a bit to the caller
to know that something has occurred.

277
00:18:04,898 --> 00:18:07,625
And this basically preserves evidence
that the exception occurred for

278
00:18:07,625 --> 00:18:10,727
higher levels of the call stacks, if they
knew that something was interrupted.

279
00:18:12,837 --> 00:18:14,520
Portable solutions for

280
00:18:14,520 --> 00:18:20,050
Java thread programming require
cooperation to stop threads.

281
00:18:20,050 --> 00:18:23,520
Threads have to check periodically
to see if they've been told to stop.

282
00:18:23,520 --> 00:18:25,288
This is rather fragile unfortunately,

283
00:18:25,288 --> 00:18:28,570
because all parts of a program have
to follow consistent usages patterns.

284
00:18:28,570 --> 00:18:33,645
You can read more about this problem in
this link and even though it tricky and

285
00:18:33,645 --> 00:18:39,057
voluntary and tedious and error prone,
it's the way to go to stop Java threads.

286
00:18:39,057 --> 00:18:43,151
So you have to understand
how these things work.

287
00:18:43,151 --> 00:18:47,980
Let's take a quick look of an example
of how to use Java thread interrupts.

288
00:18:47,980 --> 00:18:51,377
So this particular example,
you can get this from this website,

289
00:18:51,377 --> 00:18:52,996
you can take a look at the code.

290
00:18:52,996 --> 00:18:56,035
We're not going to look at the code right
now in detail, but I'll just outline it,

291
00:18:56,035 --> 00:18:57,620
because it's very simple.

292
00:18:57,620 --> 00:19:00,340
This is a program that starts,

293
00:19:00,340 --> 00:19:04,070
it has a main thread that starts a
background thread that's going to compute

294
00:19:04,070 --> 00:19:08,770
the greatest common divisor in
the background for random numbers.

295
00:19:10,010 --> 00:19:13,800
And the run hook method that's
running in the background thread

296
00:19:13,800 --> 00:19:16,520
checks periodically to see
if it's been interrupted,

297
00:19:16,520 --> 00:19:21,030
because there's no blocking calls that
are being made in the run method.

298
00:19:21,030 --> 00:19:25,410
It's just doing computation, it's not
doing calls that are going to block.

299
00:19:27,700 --> 00:19:30,517
The main thread of control sleeps for
about four seconds and

300
00:19:30,517 --> 00:19:33,062
then it sends an interrupt
to the background thread.

301
00:19:33,062 --> 00:19:35,727
And when the interrupt is sent,
then of course,

302
00:19:35,727 --> 00:19:40,342
the background thread will detect this and
check to see if it's been interrupted and

303
00:19:40,342 --> 00:19:43,606
then it'll go ahead and
exit when it has been interrupted.

